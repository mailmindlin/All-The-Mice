/*
 * MemAddr.h
 * Memory addresses for a bunch of peripherals (so if I get the addresses wrong, I can fix it without
 * changing every reference to these, like if they are different on the RPi2 for something.
 *  Created on: Feb 25, 2015
 *      Author: mailmindlin
 */

#ifndef IO_MEMADDR_HPP_
#define IO_MEMADDR_HPP_

#include <stddef.h>
#include <cstdint>

namespace MemoryMap {
typedef const uint32_t memconst_t;
typedef const uint32_t* volatile memptr_t;
typedef volatile uint32_t		REG32RW;
typedef volatile const uint32_t	REG32RO;
typedef volatile uint32_t		REG32WO;
typedef const uint32_t			RESRV32;
//Some values from https://github.com/rsta2/circle/blob/master/include/circle/bcm2835.h
#define RCST(name, base, offset)	memconst_t name = (base + offset)
#define RPTR(name, base, offset)	memptr_t name = (memptr_t)(base + offset)
#define BCST(name, offset)			RCST(name, BCM_IO_BASE, offset)
#define BPTR(name, offset)			RPTR(name, BCM_IO_BASE, offset)

#ifndef __RPI_REVISION
	#define __RPI_REVISION 2
#endif

//memconst_t GPU_BASE				= 0x7E000000;
#if __RPI_REVISION == 1
	memconst_t	BCM_IO_BASE		= 0x20000000;
#elif __RPI_REVISION == 2
	memconst_t BCM_IO_BASE		= 0x3F000000;
#endif


BCST(GPIO_BASE,0x00200000); //0x20200000
struct _GPREGS {
	REG32RW GPFSEL0		: 32;
	REG32RW GPFSEL1		: 32;
	REG32RW GPFSEL2		: 32;
	REG32RW GPFSEL3		: 32;
	REG32RW GPFSEL4		: 32;
	REG32RW GPFSEL5		: 32;
	RESRV32 RESERVED0	: 32;
	REG32WO GPSET0		: 32;
	REG32WO GPSET1		: 32;
	RESRV32 RESERVED1	: 32;
	REG32WO GPCLR0		: 32;
	REG32WO GPCLR1		: 32;
	RESRV32 RESERVED2	: 32;
	REG32RO GPLEV0		: 32;
	REG32RO GPLEV1		: 32;
	RESRV32 RESERVED3	: 32;
	REG32RW GPEDS0		: 32;
	REG32RW GPEDS1		: 32;
	RESRV32 RESERVED4	: 32;
	REG32RW GPREN0		: 32;
	REG32RW GPREN1		: 32;
	RESRV32 RESERVED5	: 32;
	REG32RW GPFEN0		: 32;
	REG32RW GPFEN1		: 32;
	RESRV32 RESERVED6	: 32;
	REG32RW GPHEN0		: 32;
	REG32RW GPHEN1		: 32;
	RESRV32 RESERVED7	: 32;
	REG32RW GPLEN0		: 32;
	REG32RW GPLEN1		: 32;
	RESRV32 RESERVED8	: 32;
	REG32RW GPAREN0		: 32;
	REG32RW GPAREN1		: 32;
	RESRV32 RESERVED9	: 32;
	REG32RW GPAFEN0		: 32;
	REG32RW GPAFEN1		: 32;
	RESRV32 RESERVEDA	: 32;
	REG32RW GPPUD		: 32;
	REG32RW GPPUDCLK0	: 32;
	REG32RW GPPUDCLK1	: 32;
	RESRV32 RESERVEDB	: 32;
	REG32RW TEST		: 32;
};
const _GPREGS *GPIO_REGS = (const _GPREGS*)GPIO_BASE;

size_t		BLOCK_SIZE			= (4*1024);
BCST(BSC0_ADDRESS, 0x00205000);
BCST(BSC1_ADDRESS, 0x00804000);
BCST(BSC2_ADDRESS, 0x00805000);

//UART0
BCST(UART0_BASE,					0x00201000);
RPTR(UART0_DR,		UART0_BASE,		0x00);
RPTR(UART0_RSRECR,	UART0_BASE,		0x04);
RPTR(UART0_FR,		UART0_BASE,		0x18);
RPTR(UART0_ILPR,	UART0_BASE,		0x20);
RPTR(UART0_IBRD,	UART0_BASE,		0x24);
RPTR(UART0_FBRD,	UART0_BASE,		0x28);
RPTR(UART0_LCRH,	UART0_BASE,		0x2C);
RPTR(UART0_CR,		UART0_BASE,		0x30);
RPTR(UART0_IFLS,	UART0_BASE,		0x34);
RPTR(UART0_IMSC,	UART0_BASE,		0x38);
RPTR(UART0_RIS,		UART0_BASE,		0x3C);
RPTR(UART0_MIS,		UART0_BASE,		0x40);
RPTR(UART0_ICR,		UART0_BASE,		0x44);
RPTR(UART0_DMACR,	UART0_BASE,		0x48);
RPTR(UART0_ITCR,	UART0_BASE,		0x80);
RPTR(UART0_ITIP,	UART0_BASE,		0x84);
RPTR(UART0_ITOP,	UART0_BASE,		0x88);
RPTR(UART0_TDR,		UART0_BASE,		0x8C);

/**
 * System timers
 */
BCST(SYSTIMER_BASE,					0x00003000);
RPTR(SYSTIMER_CS,	SYSTIMER_BASE,	0x00);
RPTR(SYSTIMER_CLO,	SYSTIMER_BASE,	0x04);
RPTR(SYSTIMER_CHI,	SYSTIMER_BASE,	0x08);
RPTR(SYSTIMER_C0,	SYSTIMER_BASE,	0x0C);
RPTR(SYSTIMER_C1,	SYSTIMER_BASE,	0x10);
RPTR(SYSTIMER_C2,	SYSTIMER_BASE,	0x14);
RPTR(SYSTIMER_C3,	SYSTIMER_BASE,	0x18);

/**
 * Platform DMA controller
 */
BCST(DMA_BASE,							0x00007000);


/**
 * Interrupt controller
 */
BCST(IC_BASE,							0x0000B200);
RPTR(IC_IRQ_BASIC_PENDING,	IC_BASE,	0x00);
RPTR(IC_IRQ_PENDING_1,		IC_BASE,	0x04);
RPTR(IC_IRQ_PENDING_2,		IC_BASE,	0x08);
RPTR(IC_FIQ_CONTROL,		IC_BASE,	0x0C);
RPTR(IC_ENABLE_IRQS_1,		IC_BASE,	0x10);
RPTR(IC_ENABLE_IRQS_2,		IC_BASE,	0x14);
RPTR(IC_ENABLE_BASIC_IRQS,	IC_BASE,	0x18);
RPTR(IC_DISABLE_IRQS_1,		IC_BASE,	0x1C);
RPTR(IC_DISABLE_IRQS_2,		IC_BASE,	0x20);
RPTR(IC_DISABLE_BASIC_IRQS,	IC_BASE,	0x24);

/**
 * ARM timer
 */
BCST(ARMTIMER_BASE,						0x0000B400);
RPTR(ARMTIMER_LOAD,		ARMTIMER_BASE,	0x00);
RPTR(ARMTIMER_VALUE,	ARMTIMER_BASE,	0x04);
RPTR(ARMTIMER_CTRL,		ARMTIMER_BASE,	0x08);
RPTR(ARMTIMER_IRQCLR,	ARMTIMER_BASE,	0x0C);
RPTR(ARMTIMER_RAWIRQ,	ARMTIMER_BASE,	0x10);
RPTR(ARMTIMER_MASKIRQ,	ARMTIMER_BASE,	0x14);
RPTR(ARMTIMER_RELOAD,	ARMTIMER_BASE,	0x18);
RPTR(ARMTIMER_PREDIV,	ARMTIMER_BASE,	0x1C);
RPTR(ARMTIMER_CNTR,		ARMTIMER_BASE,	0x20);


//GPU addresses
BCST(GPU_BASE,						0x0000B880);
RPTR(GPU_READ,		GPU_BASE,		0x00);
RPTR(GPU_POLL,		GPU_BASE,		0x10);
RPTR(GPU_SENDER,	GPU_BASE,		0x14);
RPTR(GPU_STATUS,	GPU_BASE,		0x18);
RPTR(GPU_CONFIG,	GPU_BASE,		0x1C);
RPTR(GPU_WRITE,		GPU_BASE,		0x20);


BCST(EMMC_BASE, 0x00300000);
}
#endif /* IO_MEMADDR_HPP_ */
